<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>pbrt: nurbs.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>nurbs.cpp</h1><a href="nurbs_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">/*</span>
<a name="l00003"></a>00003 <span class="comment">    pbrt source code Copyright(c) 1998-2007 Matt Pharr and Greg Humphreys.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">    This file is part of pbrt.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">    pbrt is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">    (at your option) any later version.  Note that the text contents of</span>
<a name="l00011"></a>00011 <span class="comment">    the book "Physically Based Rendering" are *not* licensed under the</span>
<a name="l00012"></a>00012 <span class="comment">    GNU GPL.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    pbrt is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">    GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    You should have received a copy of the GNU General Public License</span>
<a name="l00020"></a>00020 <span class="comment">    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment"> */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">// nurbs.cpp*</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include "<a class="code" href="shape_8h.html">shape.h</a>"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "<a class="code" href="geometry_8h.html">geometry.h</a>"</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include "<a class="code" href="dynload_8h.html">dynload.h</a>"</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include "<a class="code" href="texture_8h.html">texture.h</a>"</span>
<a name="l00030"></a>00030 <span class="comment">// NURBS Declarations</span>
<a name="l00031"></a><a class="code" href="classNURBS.html">00031</a> <span class="keyword">class </span><a class="code" href="classNURBS.html">NURBS</a> : <span class="keyword">public</span> <a class="code" href="classShape.html">Shape</a> {
<a name="l00032"></a>00032 <span class="keyword">public</span>:
<a name="l00033"></a>00033         <span class="comment">// NURBS Methods</span>
<a name="l00034"></a>00034         <a class="code" href="classNURBS.html#b48227dcc8bb266567b03750189d3b59">NURBS</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> <a class="code" href="classShape.html#337c63db30f17a31ac81a8921ec97872">reverseOrientation</a>, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a>,
<a name="l00035"></a>00035                 <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#546b3955e29308318cd9b385ae8a4f21">uknot</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#4aafe9173794974e43dc0ffcf9bd9085">umin</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#bf1e9bf302eea3fdaddbdbf5d1231c8b">umax</a>,
<a name="l00036"></a>00036                 <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a>, <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">vknot</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#d88a01d7c9661dd1871406695268eafe">vmin</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#a03a57301aeaa669758a925c059a1da2">vmax</a>,
<a name="l00037"></a>00037                 <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>, <span class="keywordtype">bool</span> <a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a>);
<a name="l00038"></a>00038         <a class="code" href="classNURBS.html#0037a435a7adcd2cff79b687c39d8cce">~NURBS</a>();
<a name="l00039"></a>00039         <span class="keyword">virtual</span> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#e0235d6d98827e1b70e8a55a6f95189d">ObjectBound</a>() <span class="keyword">const</span>;
<a name="l00040"></a>00040         <span class="keyword">virtual</span> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#9b3ff6db0b2f85dbeccf13ec5111a26f">WorldBound</a>() <span class="keyword">const</span>;
<a name="l00041"></a><a class="code" href="classNURBS.html#ac50cb4f4e57bd93dbc1d5f2c923ec38">00041</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classNURBS.html#ac50cb4f4e57bd93dbc1d5f2c923ec38">CanIntersect</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00042"></a>00042         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classNURBS.html#9eaff5946f399c0da92099f8eb54f060">Refine</a>(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined) <span class="keyword">const</span>;
<a name="l00043"></a>00043 <span class="keyword">private</span>:
<a name="l00044"></a>00044         <span class="comment">// NURBS Data</span>
<a name="l00045"></a><a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">00045</a>         <span class="keywordtype">int</span> nu, uorder, nv, vorder;
<a name="l00046"></a><a class="code" href="classNURBS.html#d88a01d7c9661dd1871406695268eafe">00046</a>         <span class="keywordtype">float</span> umin, umax, vmin, vmax;
<a name="l00047"></a><a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">00047</a>         <span class="keywordtype">float</span> *uknot, *vknot;
<a name="l00048"></a><a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">00048</a>         <span class="keywordtype">bool</span> isHomogeneous;
<a name="l00049"></a><a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">00049</a>         <span class="keywordtype">float</span> *P;
<a name="l00050"></a>00050 };
<a name="l00051"></a>00051 <span class="comment">// NURBS Evaluation Functions</span>
<a name="l00052"></a><a class="code" href="nurbs_8cpp.html#cf5bb0206850363885e15053b8301614">00052</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="nurbs_8cpp.html#cf5bb0206850363885e15053b8301614">KnotOffset</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *knot, <span class="keywordtype">int</span> order, <span class="keywordtype">int</span> np, <span class="keywordtype">float</span> t) {
<a name="l00053"></a>00053     <span class="keywordtype">int</span> firstKnot = order - 1;
<a name="l00054"></a>00054     <span class="keywordtype">int</span> lastKnot = np;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="keywordtype">int</span> knotOffset = firstKnot;
<a name="l00057"></a>00057     <span class="keywordflow">while</span> (t &gt; knot[knotOffset+1])
<a name="l00058"></a>00058         ++knotOffset;
<a name="l00059"></a>00059     assert(knotOffset &lt; lastKnot);
<a name="l00060"></a>00060     assert(t &gt;= knot[knotOffset] &amp;&amp; t &lt;= knot[knotOffset + 1]);
<a name="l00061"></a>00061     <span class="keywordflow">return</span> knotOffset;
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">// doesn't handle flat out discontinuities in the curve...</span>
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="structHomogeneous3.html">00066</a> <span class="keyword">struct </span><a class="code" href="structHomogeneous3.html">Homogeneous3</a> {
<a name="l00067"></a><a class="code" href="structHomogeneous3.html#9faba6730504e5ce9b982fb950e38f54">00067</a> <a class="code" href="structHomogeneous3.html#9faba6730504e5ce9b982fb950e38f54">Homogeneous3</a>() { <a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> = <a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> = <a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> = <a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> = 0.; }
<a name="l00068"></a><a class="code" href="structHomogeneous3.html#45d7cd50340ece3aad0fa49a3f234396">00068</a> <a class="code" href="structHomogeneous3.html#9faba6730504e5ce9b982fb950e38f54">Homogeneous3</a>(<span class="keywordtype">float</span> xx, <span class="keywordtype">float</span> yy, <span class="keywordtype">float</span> zz, <span class="keywordtype">float</span> ww) {
<a name="l00069"></a>00069     <a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> = xx; <a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> = yy; <a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> = zz; <a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> = ww;
<a name="l00070"></a>00070 }
<a name="l00071"></a><a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">00071</a> <span class="keywordtype">float</span> <a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a>, <a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a>, <a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a>, <a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>;
<a name="l00072"></a>00072 };
<a name="l00073"></a>00073 <span class="keyword">static</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a>
<a name="l00074"></a><a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">00074</a> <a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">NURBSEvaluate</a>(<span class="keywordtype">int</span> order, <span class="keyword">const</span> <span class="keywordtype">float</span> *knot, <span class="keyword">const</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cp, <span class="keywordtype">int</span> np,
<a name="l00075"></a>00075               <span class="keywordtype">int</span> cpStride, <span class="keywordtype">float</span> t, <a class="code" href="classVector.html">Vector</a> *deriv = NULL) {
<a name="l00076"></a>00076 <span class="comment">//    int nKnots = np + order;</span>
<a name="l00077"></a>00077     <span class="keywordtype">float</span> alpha;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     <span class="keywordtype">int</span> knotOffset = <a class="code" href="nurbs_8cpp.html#cf5bb0206850363885e15053b8301614">KnotOffset</a>(knot, order, np, t);
<a name="l00080"></a>00080     knot += knotOffset;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="keywordtype">int</span> cpOffset = knotOffset - order + 1;
<a name="l00083"></a>00083     assert(cpOffset &gt;= 0 &amp;&amp; cpOffset &lt; np);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cpWork =
<a name="l00086"></a>00086         (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(order * <span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
<a name="l00087"></a>00087     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; order; ++i)
<a name="l00088"></a>00088         cpWork[i] = cp[(cpOffset+i) * cpStride];
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; order - 2; ++i)
<a name="l00091"></a>00091         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; order - 1 - i; ++j) {
<a name="l00092"></a>00092             alpha = (knot[1 + j] - t) /
<a name="l00093"></a>00093                 (knot[1 + j] - knot[j + 2 - order + i]);
<a name="l00094"></a>00094             assert(alpha &gt;= 0. &amp;&amp; alpha &lt;= 1.);
<a name="l00095"></a>00095 
<a name="l00096"></a>00096             cpWork[j].<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> = cpWork[j].<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> * alpha + cpWork[j+1].<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> * (1 - alpha);
<a name="l00097"></a>00097             cpWork[j].<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> = cpWork[j].<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> * alpha + cpWork[j+1].<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> * (1 - alpha);
<a name="l00098"></a>00098             cpWork[j].<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> = cpWork[j].<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> * alpha + cpWork[j+1].<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> * (1 - alpha);
<a name="l00099"></a>00099             cpWork[j].<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> = cpWork[j].<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> * alpha + cpWork[j+1].<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> * (1 - alpha);
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     alpha = (knot[1] - t) / (knot[1] - knot[0]);
<a name="l00103"></a>00103     assert(alpha &gt;= 0. &amp;&amp; alpha &lt;= 1.);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> val(cpWork[0].x * alpha + cpWork[1].x * (1 - alpha),
<a name="l00106"></a>00106                      cpWork[0].y * alpha + cpWork[1].y * (1 - alpha),
<a name="l00107"></a>00107                      cpWork[0].z * alpha + cpWork[1].z * (1 - alpha),
<a name="l00108"></a>00108                      cpWork[0].w * alpha + cpWork[1].w * (1 - alpha));
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="keywordflow">if</span> (deriv) {
<a name="l00111"></a>00111                 <span class="keywordtype">float</span> factor = (order - 1) / (knot[1] - knot[0]);
<a name="l00112"></a>00112                 <a class="code" href="structHomogeneous3.html">Homogeneous3</a> delta((cpWork[1].x - cpWork[0].x) * factor,
<a name="l00113"></a>00113                            (cpWork[1].y - cpWork[0].y) * factor,
<a name="l00114"></a>00114                            (cpWork[1].z - cpWork[0].z) * factor,
<a name="l00115"></a>00115                            (cpWork[1].w - cpWork[0].w) * factor);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117                 deriv-&gt;x = delta.<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> / val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> - (val.<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> * delta.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> / (val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> * val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>));
<a name="l00118"></a>00118                 deriv-&gt;y = delta.<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> / val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> - (val.<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> * delta.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> / (val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> * val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>));
<a name="l00119"></a>00119                 deriv-&gt;z = delta.<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> / val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> - (val.<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> * delta.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> / (val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> * val.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>));
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="keywordflow">return</span> val;
<a name="l00123"></a>00123 }
<a name="l00124"></a>00124 <span class="keyword">static</span> <a class="code" href="classPoint.html">Point</a>
<a name="l00125"></a><a class="code" href="nurbs_8cpp.html#b1a2b2325ff03e948e2eab1e190662c4">00125</a> <a class="code" href="nurbs_8cpp.html#b1a2b2325ff03e948e2eab1e190662c4">NURBSEvaluateSurface</a>(<span class="keywordtype">int</span> uOrder, <span class="keyword">const</span> <span class="keywordtype">float</span> *uKnot, <span class="keywordtype">int</span> ucp, <span class="keywordtype">float</span> u,
<a name="l00126"></a>00126                      <span class="keywordtype">int</span> vOrder, <span class="keyword">const</span> <span class="keywordtype">float</span> *vKnot, <span class="keywordtype">int</span> vcp, <span class="keywordtype">float</span> v,
<a name="l00127"></a>00127                      <span class="keyword">const</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cp, <a class="code" href="classVector.html">Vector</a> *dPdu, <a class="code" href="classVector.html">Vector</a> *dPdv) {
<a name="l00128"></a>00128     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *iso = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(max(uOrder, vOrder) *
<a name="l00129"></a>00129                                                <span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordtype">int</span> uOffset = <a class="code" href="nurbs_8cpp.html#cf5bb0206850363885e15053b8301614">KnotOffset</a>(uKnot, uOrder, ucp, u);
<a name="l00132"></a>00132     <span class="keywordtype">int</span> uFirstCp = uOffset - uOrder + 1;
<a name="l00133"></a>00133     assert(uFirstCp &gt;= 0 &amp;&amp; uFirstCp + uOrder - 1 &lt; ucp);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; uOrder; ++i)
<a name="l00136"></a>00136                 iso[i] = <a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">NURBSEvaluate</a>(vOrder, vKnot, &amp;cp[uFirstCp + i], vcp,
<a name="l00137"></a>00137                                ucp, v);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="keywordtype">int</span> vOffset = <a class="code" href="nurbs_8cpp.html#cf5bb0206850363885e15053b8301614">KnotOffset</a>(vKnot, vOrder, vcp, v);
<a name="l00140"></a>00140     <span class="keywordtype">int</span> vFirstCp = vOffset - vOrder + 1;
<a name="l00141"></a>00141     assert(vFirstCp &gt;= 0 &amp;&amp; vFirstCp + vOrder - 1 &lt; vcp);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> P = <a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">NURBSEvaluate</a>(uOrder, uKnot, iso - uFirstCp, ucp,
<a name="l00144"></a>00144                                    1, u, dPdu);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keywordflow">if</span> (dPdv) {
<a name="l00147"></a>00147                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vOrder; ++i)
<a name="l00148"></a>00148                     iso[i] = <a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">NURBSEvaluate</a>(uOrder, uKnot, &amp;cp[(vFirstCp+i)*ucp], ucp,
<a name="l00149"></a>00149                                    1, u);
<a name="l00150"></a>00150                 (void)<a class="code" href="nurbs_8cpp.html#326e051501ef7d4c89e4bf76d4e2a301">NURBSEvaluate</a>(vOrder, vKnot, iso - vFirstCp, vcp, 1, v, dPdv);
<a name="l00151"></a>00151     }
<a name="l00152"></a>00152     <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point</a>(P.<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a>/P.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>, P.<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a>/P.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>, P.<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a>/P.<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a>);;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 <span class="comment">// NURBS Definitions</span>
<a name="l00155"></a><a class="code" href="classNURBS.html#b48227dcc8bb266567b03750189d3b59">00155</a> <a class="code" href="classNURBS.html#b48227dcc8bb266567b03750189d3b59">NURBS::NURBS</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> ro, <span class="keywordtype">int</span> numu, <span class="keywordtype">int</span> uo, <span class="keyword">const</span> <span class="keywordtype">float</span> *uk,
<a name="l00156"></a>00156                 <span class="keywordtype">float</span> u0, <span class="keywordtype">float</span> u1, <span class="keywordtype">int</span> numv, <span class="keywordtype">int</span> vo, <span class="keyword">const</span> <span class="keywordtype">float</span> *vk,
<a name="l00157"></a>00157                 <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keyword">const</span> <span class="keywordtype">float</span> *p, <span class="keywordtype">bool</span> homogeneous)
<a name="l00158"></a>00158         : <a class="code" href="classShape.html">Shape</a>(o2w, ro) {
<a name="l00159"></a>00159         <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a> = numu;    <a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a> = uo;
<a name="l00160"></a>00160         <a class="code" href="classNURBS.html#4aafe9173794974e43dc0ffcf9bd9085">umin</a> = u0;    <a class="code" href="classNURBS.html#bf1e9bf302eea3fdaddbdbf5d1231c8b">umax</a> = u1;
<a name="l00161"></a>00161         <a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a> = numv;    <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a> = vo;
<a name="l00162"></a>00162         <a class="code" href="classNURBS.html#d88a01d7c9661dd1871406695268eafe">vmin</a> = v0;    <a class="code" href="classNURBS.html#a03a57301aeaa669758a925c059a1da2">vmax</a> = v1;
<a name="l00163"></a>00163         <a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a> = homogeneous;
<a name="l00164"></a>00164         <span class="keywordflow">if</span> (<a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a>) {
<a name="l00165"></a>00165                 <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[4*<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>];
<a name="l00166"></a>00166                 <a class="code" href="pbrtparse_8y.html#2ac249754cc680184bc1b7825aacb876">memcpy</a>(<a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>, p, 4*<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00167"></a>00167         } <span class="keywordflow">else</span> {
<a name="l00168"></a>00168                 <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[3*<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>];
<a name="l00169"></a>00169                 <a class="code" href="pbrtparse_8y.html#2ac249754cc680184bc1b7825aacb876">memcpy</a>(<a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>, p, 3*<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171         <a class="code" href="classNURBS.html#546b3955e29308318cd9b385ae8a4f21">uknot</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a> + <a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a>];
<a name="l00172"></a>00172         <a class="code" href="pbrtparse_8y.html#2ac249754cc680184bc1b7825aacb876">memcpy</a>(<a class="code" href="classNURBS.html#546b3955e29308318cd9b385ae8a4f21">uknot</a>, uk, (<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a> + <a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a>) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00173"></a>00173         <a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">vknot</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a> + <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a>];
<a name="l00174"></a>00174         <a class="code" href="pbrtparse_8y.html#2ac249754cc680184bc1b7825aacb876">memcpy</a>(<a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">vknot</a>, vk, (<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a> + <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a>) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00175"></a>00175 }
<a name="l00176"></a><a class="code" href="classNURBS.html#0037a435a7adcd2cff79b687c39d8cce">00176</a> <a class="code" href="classNURBS.html#0037a435a7adcd2cff79b687c39d8cce">NURBS::~NURBS</a>() {
<a name="l00177"></a>00177         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00178"></a>00178         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#546b3955e29308318cd9b385ae8a4f21">uknot</a>;
<a name="l00179"></a>00179         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">vknot</a>;
<a name="l00180"></a>00180 }
<a name="l00181"></a><a class="code" href="classNURBS.html#e0235d6d98827e1b70e8a55a6f95189d">00181</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#e0235d6d98827e1b70e8a55a6f95189d">NURBS::ObjectBound</a>()<span class="keyword"> const </span>{
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a>) {
<a name="l00183"></a>00183                 <span class="comment">// Compute object-space bound of non-homogeneous NURBS</span>
<a name="l00184"></a>00184                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00185"></a>00185                 <a class="code" href="classBBox.html">BBox</a> bound = <a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]);
<a name="l00186"></a>00186                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>; ++i, pp += 3)
<a name="l00187"></a>00187                         bound = <a class="code" href="geometry_8cpp.html#b6b355a05ae9130aceaa5ed34f3eb75b">Union</a>(bound, <a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]));
<a name="l00188"></a>00188                 <span class="keywordflow">return</span> bound;
<a name="l00189"></a>00189         } <span class="keywordflow">else</span> {
<a name="l00190"></a>00190                 <span class="comment">// Compute object-space bound of homogeneous NURBS</span>
<a name="l00191"></a>00191                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00192"></a>00192                 <a class="code" href="classBBox.html">BBox</a> bound = <a class="code" href="classPoint.html">Point</a>(pp[0] / pp[3], pp[1] / pp[3], pp[2] / pp[3]);
<a name="l00193"></a>00193                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>; ++i, pp += 4)
<a name="l00194"></a>00194                         bound = <a class="code" href="geometry_8cpp.html#b6b355a05ae9130aceaa5ed34f3eb75b">Union</a>(bound, <a class="code" href="classPoint.html">Point</a>(pp[0] / pp[3], pp[1] / pp[3], pp[2] / pp[3]));
<a name="l00195"></a>00195                 <span class="keywordflow">return</span> bound;
<a name="l00196"></a>00196         }
<a name="l00197"></a>00197 }
<a name="l00198"></a><a class="code" href="classNURBS.html#9b3ff6db0b2f85dbeccf13ec5111a26f">00198</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#9b3ff6db0b2f85dbeccf13ec5111a26f">NURBS::WorldBound</a>()<span class="keyword"> const </span>{
<a name="l00199"></a>00199         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a>) {
<a name="l00200"></a>00200                 <span class="comment">// Compute world-space bound of non-homogeneous NURBS</span>
<a name="l00201"></a>00201                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00202"></a>00202                 <a class="code" href="classPoint.html">Point</a> pt = <a class="code" href="classShape.html#7c8a34f400c3a5ad7cfd2395836cda03">ObjectToWorld</a>(<a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]));
<a name="l00203"></a>00203                 <a class="code" href="classBBox.html">BBox</a> bound = pt;
<a name="l00204"></a>00204                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>; ++i, pp += 3) {
<a name="l00205"></a>00205                         pt = <a class="code" href="classShape.html#7c8a34f400c3a5ad7cfd2395836cda03">ObjectToWorld</a>(<a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]));
<a name="l00206"></a>00206                         bound = <a class="code" href="geometry_8cpp.html#b6b355a05ae9130aceaa5ed34f3eb75b">Union</a>(bound, pt);
<a name="l00207"></a>00207                 }
<a name="l00208"></a>00208                 <span class="keywordflow">return</span> bound;
<a name="l00209"></a>00209         } <span class="keywordflow">else</span> {
<a name="l00210"></a>00210                 <span class="comment">// Compute world-space bound of homogeneous NURBS</span>
<a name="l00211"></a>00211                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00212"></a>00212                 <a class="code" href="classPoint.html">Point</a> pt = <a class="code" href="classShape.html#7c8a34f400c3a5ad7cfd2395836cda03">ObjectToWorld</a>(<a class="code" href="classPoint.html">Point</a>(pp[0]/pp[3],
<a name="l00213"></a>00213                         pp[1]/pp[3], pp[2]/pp[3]));
<a name="l00214"></a>00214                 <a class="code" href="classBBox.html">BBox</a> bound = pt;
<a name="l00215"></a>00215                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>; ++i, pp += 4) {
<a name="l00216"></a>00216                         pt = <a class="code" href="classShape.html#7c8a34f400c3a5ad7cfd2395836cda03">ObjectToWorld</a>(<a class="code" href="classPoint.html">Point</a>(pp[0]/pp[3],
<a name="l00217"></a>00217                                 pp[1]/pp[3], pp[2]/pp[3]));
<a name="l00218"></a>00218                         bound = <a class="code" href="geometry_8cpp.html#b6b355a05ae9130aceaa5ed34f3eb75b">Union</a>(bound, pt);
<a name="l00219"></a>00219                 }
<a name="l00220"></a>00220                 <span class="keywordflow">return</span> bound;
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a><a class="code" href="classNURBS.html#9eaff5946f399c0da92099f8eb54f060">00224</a> <span class="keywordtype">void</span> <a class="code" href="classNURBS.html#9eaff5946f399c0da92099f8eb54f060">NURBS::Refine</a>(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined)<span class="keyword"> const </span>{
<a name="l00225"></a>00225         <span class="comment">// Compute NURBS dicing rates</span>
<a name="l00226"></a>00226         <span class="keywordtype">int</span> diceu = 30, dicev = 30;
<a name="l00227"></a>00227         <span class="keywordtype">float</span> *ueval = <span class="keyword">new</span> <span class="keywordtype">float</span>[diceu];
<a name="l00228"></a>00228         <span class="keywordtype">float</span> *veval = <span class="keyword">new</span> <span class="keywordtype">float</span>[dicev];
<a name="l00229"></a>00229         <a class="code" href="classPoint.html">Point</a> *evalPs = <span class="keyword">new</span> <a class="code" href="classPoint.html">Point</a>[diceu*dicev];
<a name="l00230"></a>00230         <a class="code" href="classNormal.html">Normal</a> *evalNs = <span class="keyword">new</span> <a class="code" href="classNormal.html">Normal</a>[diceu*dicev];
<a name="l00231"></a>00231         <span class="keywordtype">int</span> i;
<a name="l00232"></a>00232         <span class="keywordflow">for</span> (i = 0; i &lt; diceu; ++i)
<a name="l00233"></a>00233                 ueval[i] = <a class="code" href="pbrt_8h.html#0934d1ba879ec4edf23b9c3bc4e52b35">Lerp</a>((<span class="keywordtype">float</span>)i / (<span class="keywordtype">float</span>)(diceu-1), <a class="code" href="classNURBS.html#4aafe9173794974e43dc0ffcf9bd9085">umin</a>, <a class="code" href="classNURBS.html#bf1e9bf302eea3fdaddbdbf5d1231c8b">umax</a>);
<a name="l00234"></a>00234         <span class="keywordflow">for</span> (i = 0; i &lt; dicev; ++i)
<a name="l00235"></a>00235                 veval[i] = <a class="code" href="pbrt_8h.html#0934d1ba879ec4edf23b9c3bc4e52b35">Lerp</a>((<span class="keywordtype">float</span>)i / (<span class="keywordtype">float</span>)(dicev-1), <a class="code" href="classNURBS.html#d88a01d7c9661dd1871406695268eafe">vmin</a>, <a class="code" href="classNURBS.html#a03a57301aeaa669758a925c059a1da2">vmax</a>);
<a name="l00236"></a>00236         <span class="comment">// Evaluate NURBS over grid of points</span>
<a name="l00237"></a>00237         memset(evalPs, 0, diceu*dicev*<span class="keyword">sizeof</span>(<a class="code" href="classPoint.html">Point</a>));
<a name="l00238"></a>00238         memset(evalNs, 0, diceu*dicev*<span class="keyword">sizeof</span>(<a class="code" href="classPoint.html">Point</a>));
<a name="l00239"></a>00239         <span class="keywordtype">float</span> *uvs = <span class="keyword">new</span> <span class="keywordtype">float</span>[2*diceu*dicev];
<a name="l00240"></a>00240         <span class="comment">// Turn NURBS into triangles</span>
<a name="l00241"></a>00241         <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *Pw = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)<a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>;
<a name="l00242"></a>00242         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a>) {
<a name="l00243"></a>00243                 Pw = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(<a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>*<span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
<a name="l00244"></a>00244                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>*<a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>; ++i) {
<a name="l00245"></a>00245                         Pw[i].<a class="code" href="structHomogeneous3.html#7d25fb6bfdc1f67c3c9a13c8d65382be">x</a> = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>[3*i];
<a name="l00246"></a>00246                         Pw[i].<a class="code" href="structHomogeneous3.html#e22acc4d032faebfefb4a9f8d605cac3">y</a> = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>[3*i+1];
<a name="l00247"></a>00247                         Pw[i].<a class="code" href="structHomogeneous3.html#154a9df60ab557d28986cd070912d5a2">z</a> = <a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a>[3*i+2];
<a name="l00248"></a>00248                         Pw[i].<a class="code" href="structHomogeneous3.html#266f30d33f4fe93e6a2dbf1cd57cb027">w</a> = 1.;
<a name="l00249"></a>00249                 }
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; dicev; ++v) {
<a name="l00252"></a>00252                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; u &lt; diceu; ++u) {
<a name="l00253"></a>00253                         uvs[2*(v*diceu+u)]   = ueval[u];
<a name="l00254"></a>00254                         uvs[2*(v*diceu+u)+1] = veval[v];
<a name="l00255"></a>00255         
<a name="l00256"></a>00256                         <a class="code" href="classVector.html">Vector</a> dPdu, dPdv;
<a name="l00257"></a>00257                         <a class="code" href="classPoint.html">Point</a> pt = <a class="code" href="nurbs_8cpp.html#b1a2b2325ff03e948e2eab1e190662c4">NURBSEvaluateSurface</a>(<a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a>, <a class="code" href="classNURBS.html#546b3955e29308318cd9b385ae8a4f21">uknot</a>, <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a>, ueval[u],
<a name="l00258"></a>00258                                 <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a>, <a class="code" href="classNURBS.html#35813fd35bd6592ce183baec9a4b0465">vknot</a>, <a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a>, veval[v], Pw, &amp;dPdu, &amp;dPdv);
<a name="l00259"></a>00259                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#05dfe2dfbde813ad234b514f30e662f1">x</a> = pt.<a class="code" href="classPoint.html#05dfe2dfbde813ad234b514f30e662f1">x</a>;
<a name="l00260"></a>00260                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#6101960c8d2d4e8ea1d32c9234bbeb8d">y</a> = pt.<a class="code" href="classPoint.html#6101960c8d2d4e8ea1d32c9234bbeb8d">y</a>;
<a name="l00261"></a>00261                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#9a666531e0e99adff132be93d2407d0c">z</a> = pt.<a class="code" href="classPoint.html#9a666531e0e99adff132be93d2407d0c">z</a>;
<a name="l00262"></a>00262                         evalNs[v*diceu + u] = <a class="code" href="classNormal.html">Normal</a>(<a class="code" href="geometry_8h.html#46448bfa3df1c2de5e3b763f163866a4">Normalize</a>(<a class="code" href="geometry_8h.html#340d6d877ba46443c9ad20e7c0d0668f">Cross</a>(dPdu, dPdv)));
<a name="l00263"></a>00263                 }
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265         <span class="comment">// Generate points-polygons mesh</span>
<a name="l00266"></a>00266         <span class="keywordtype">int</span> nTris = 2*(diceu-1)*(dicev-1);
<a name="l00267"></a>00267         <span class="keywordtype">int</span> *vertices = <span class="keyword">new</span> <span class="keywordtype">int</span>[3 * nTris];
<a name="l00268"></a>00268         <span class="keywordtype">int</span> *vertp = vertices;
<a name="l00269"></a>00269         <span class="comment">// Compute the vertex offset numbers for the triangles</span>
<a name="l00270"></a>00270         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; dicev-1; ++v) {
<a name="l00271"></a>00271                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; u &lt; diceu-1; ++u) {
<a name="l00272"></a>00272 <span class="preprocessor">        #define VN(u,v) ((v)*diceu+(u))</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>                        *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u,   v);
<a name="l00274"></a>00274                         *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u+1, v);
<a name="l00275"></a>00275                         *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u+1, v+1);
<a name="l00276"></a>00276         
<a name="l00277"></a>00277                         *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u,   v);
<a name="l00278"></a>00278                         *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u+1, v+1);
<a name="l00279"></a>00279                         *vertp++ = <a class="code" href="nurbs_8cpp.html#960f67711c5463e544829c60a6d63399">VN</a>(u,   v+1);
<a name="l00280"></a>00280 <span class="preprocessor">        #undef VN</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>                }
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         <span class="keywordtype">int</span> nVerts = diceu*dicev;
<a name="l00284"></a>00284         <a class="code" href="classParamSet.html">ParamSet</a> paramSet;
<a name="l00285"></a>00285         paramSet.<a class="code" href="classParamSet.html#a060eb7d26fbe23b4552c5d15db45893">AddInt</a>(<span class="stringliteral">"indices"</span>, vertices, 3*nTris);
<a name="l00286"></a>00286         paramSet.<a class="code" href="classParamSet.html#0310e513958cc1d90abd58be2b5c880a">AddPoint</a>(<span class="stringliteral">"P"</span>, evalPs, nVerts);
<a name="l00287"></a>00287         paramSet.<a class="code" href="classParamSet.html#772f38668c43b4b54486fa94d231c5be">AddFloat</a>(<span class="stringliteral">"uv"</span>, uvs, 2 * nVerts);
<a name="l00288"></a>00288         paramSet.<a class="code" href="classParamSet.html#d8a29375a718eed332866f81830f8b6c">AddNormal</a>(<span class="stringliteral">"N"</span>, evalNs, nVerts);
<a name="l00289"></a>00289         refined.push_back(<a class="code" href="dynload_8cpp.html#7cafb1faa059017c7ee7e46bb3fd4fec">MakeShape</a>(<span class="stringliteral">"trianglemesh"</span>, <a class="code" href="classShape.html#7c8a34f400c3a5ad7cfd2395836cda03">ObjectToWorld</a>,
<a name="l00290"></a>00290                         <a class="code" href="classShape.html#337c63db30f17a31ac81a8921ec97872">reverseOrientation</a>, paramSet));
<a name="l00291"></a>00291         <span class="comment">// Cleanup from NURBS refinement</span>
<a name="l00292"></a>00292         <span class="keyword">delete</span>[] uvs;
<a name="l00293"></a>00293         <span class="keyword">delete</span>[] ueval;
<a name="l00294"></a>00294         <span class="keyword">delete</span>[] veval;
<a name="l00295"></a>00295         <span class="keyword">delete</span>[] evalPs;
<a name="l00296"></a>00296         <span class="keyword">delete</span>[] evalNs;
<a name="l00297"></a>00297         <span class="keyword">delete</span>[] vertices;
<a name="l00298"></a>00298 }
<a name="l00299"></a><a class="code" href="nurbs_8cpp.html#3ca5abc6928b2220103b7f077e0471e1">00299</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#808e08638be3cba36e36759e5b150de0">DLLEXPORT</a> <a class="code" href="classShape.html">Shape</a> *<a class="code" href="cone_8cpp.html#3ca5abc6928b2220103b7f077e0471e1">CreateShape</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w,
<a name="l00300"></a>00300                 <span class="keywordtype">bool</span> <a class="code" href="classShape.html#337c63db30f17a31ac81a8921ec97872">reverseOrientation</a>, <span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;params) {
<a name="l00301"></a>00301         <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#4f5a58d63e3e3943b6c1491e89763e54">nu</a> = params.<a class="code" href="classParamSet.html#23f24db9c46375e33764910c4fa999d5">FindOneInt</a>(<span class="stringliteral">"nu"</span>, -1);
<a name="l00302"></a>00302         <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#32039d64698cd927b35d0078d56af455">uorder</a> = params.<a class="code" href="classParamSet.html#23f24db9c46375e33764910c4fa999d5">FindOneInt</a>(<span class="stringliteral">"uorder"</span>, -1);
<a name="l00303"></a>00303         <span class="keywordtype">int</span> nuknots, nvknots;
<a name="l00304"></a>00304         <span class="keyword">const</span> <span class="keywordtype">float</span> *uknots = params.<a class="code" href="classParamSet.html#16ef98ac9d59f839f08c13fb80eeeefe">FindFloat</a>(<span class="stringliteral">"uknots"</span>, &amp;nuknots);
<a name="l00305"></a>00305         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(nu != -1 &amp;&amp; uorder != -1 &amp;&amp; uknots != NULL);
<a name="l00306"></a>00306         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(nuknots == nu + uorder);
<a name="l00307"></a>00307         <span class="keywordtype">float</span> u0 = params.<a class="code" href="classParamSet.html#87143fd8e73a75082179a110d42531a4">FindOneFloat</a>(<span class="stringliteral">"u0"</span>, uknots[uorder-1]);
<a name="l00308"></a>00308         <span class="keywordtype">float</span> u1 = params.<a class="code" href="classParamSet.html#87143fd8e73a75082179a110d42531a4">FindOneFloat</a>(<span class="stringliteral">"u1"</span>, uknots[nu]);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#47f5d42f282c09b9033291e6924b61a8">nv</a> = params.<a class="code" href="classParamSet.html#23f24db9c46375e33764910c4fa999d5">FindOneInt</a>(<span class="stringliteral">"nv"</span>, -1);
<a name="l00311"></a>00311         <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#6684835adef8bd5bf46219f161067569">vorder</a> = params.<a class="code" href="classParamSet.html#23f24db9c46375e33764910c4fa999d5">FindOneInt</a>(<span class="stringliteral">"vorder"</span>, -1);
<a name="l00312"></a>00312         <span class="keyword">const</span> <span class="keywordtype">float</span> *vknots = params.<a class="code" href="classParamSet.html#16ef98ac9d59f839f08c13fb80eeeefe">FindFloat</a>(<span class="stringliteral">"vknots"</span>, &amp;nvknots);
<a name="l00313"></a>00313         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(nv != -1 &amp;&amp; vorder != -1 &amp;&amp; vknots != NULL);
<a name="l00314"></a>00314         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(nvknots == nv + vorder);
<a name="l00315"></a>00315         <span class="keywordtype">float</span> v0 = params.<a class="code" href="classParamSet.html#87143fd8e73a75082179a110d42531a4">FindOneFloat</a>(<span class="stringliteral">"v0"</span>, vknots[vorder-1]);
<a name="l00316"></a>00316         <span class="keywordtype">float</span> v1 = params.<a class="code" href="classParamSet.html#87143fd8e73a75082179a110d42531a4">FindOneFloat</a>(<span class="stringliteral">"v1"</span>, vknots[nv]);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318         <span class="keywordtype">bool</span> <a class="code" href="classNURBS.html#797a90797ade339e675df7e2e62e0bb3">isHomogeneous</a> = <span class="keyword">false</span>;
<a name="l00319"></a>00319         <span class="keywordtype">int</span> npts;
<a name="l00320"></a>00320         <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#1d06043ac25c2d809a1789729694a363">P</a> = (<span class="keyword">const</span> <span class="keywordtype">float</span> *)params.<a class="code" href="classParamSet.html#c81cf4c6ee0c96d7b6df73f4a65d86f0">FindPoint</a>(<span class="stringliteral">"P"</span>, &amp;npts);
<a name="l00321"></a>00321         <span class="keywordflow">if</span> (!P) {
<a name="l00322"></a>00322                 P = params.<a class="code" href="classParamSet.html#16ef98ac9d59f839f08c13fb80eeeefe">FindFloat</a>(<span class="stringliteral">"Pw"</span>, &amp;npts);
<a name="l00323"></a>00323                 npts /= 4;
<a name="l00324"></a>00324                 <span class="keywordflow">if</span> (!P) <span class="keywordflow">return</span> NULL;
<a name="l00325"></a>00325                 isHomogeneous = <span class="keyword">true</span>;
<a name="l00326"></a>00326         }
<a name="l00327"></a>00327         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(P);
<a name="l00328"></a>00328         <a class="code" href="pbrt_8h.html#ab1e54dcc40192f9704e8b252635450f">Assert</a>(npts == nu*nv);
<a name="l00329"></a>00329         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classNURBS.html#b48227dcc8bb266567b03750189d3b59">NURBS</a>(o2w, reverseOrientation, nu, uorder, uknots, u0, u1,
<a name="l00330"></a>00330                          nv, vorder, vknots, v0, v1, (<span class="keywordtype">float</span> *)P,
<a name="l00331"></a>00331                          isHomogeneous);
<a name="l00332"></a>00332 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 20 17:31:53 2009 for pbrt by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
